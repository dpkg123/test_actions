// __multiversion__
// This signals the loading code to prepend either #version 100 or #version 300 es as apropriate.

// To use centroid sampling we need to have version 300 es shaders, which requires changing:
// attribute to in
// varying to out when in vertex shaders or in when in fragment shaders
// defining an out vec4 FragColor and replacing uses of gl_FragColor with FragColor
// texture2D to texture

#if __VERSION__ >= 300
#define attribute in
#define varying out

#else


#endif



precision highp float;

#ifndef _UNIFORM_WORLD_CONSTANTS_H
#define _UNIFORM_WORLD_CONSTANTS_H

#ifndef _UNIFORM_MACRO_H
#define _UNIFORM_MACRO_H

#ifdef MCPE_PLATFORM_NX
// Unfortunately this macro does not work on old Amazon platforms #define BEGIN_UNIFORM_BLOCK(x) uniform x {
#define END_UNIFORM_BLOCK };
#define UNIFORM 
#else
// Unfortunately this macro does not work on old Amazon platforms #define BEGIN_UNIFORM_BLOCK(x) 
#define END_UNIFORM_BLOCK
#define UNIFORM uniform 
#endif

#if __VERSION__ >= 420
#define LAYOUT_BINDING(x) layout(binding = x)
#else
#define LAYOUT_BINDING(x) 
#endif

#endif


#ifdef MCPE_PLATFORM_NX
layout(binding = 1) uniform WorldConstants {
#endif
// BEGIN_UNIFORM_BLOCK(WorldConstants) - unfortunately this macro does not work on old Amazon platforms so using above 3 lines instead
UNIFORM MAT4 WORLDVIEWPROJ;
UNIFORM MAT4 WORLD;
UNIFORM MAT4 WORLDVIEW;
UNIFORM MAT4 PROJ;
END_UNIFORM_BLOCK

#endif

#ifndef _UNIFORM_WEATHER_CONSTANTS_H
#define _UNIFORM_WEATHER_CONSTANTS_H



#ifdef MCPE_PLATFORM_NX
uniform WeatherConstants {
#endif
// BEGIN_UNIFORM_BLOCK(WeatherConstants) - unfortunately this macro does not work on old Amazon platforms so using above 3 lines instead
UNIFORM vec4 POSITION_OFFSET;
UNIFORM vec4 VELOCITY;
UNIFORM vec4 ALPHA;
UNIFORM vec4 VIEW_POSITION;
UNIFORM vec4 SIZE_SCALE;
UNIFORM vec4 FORWARD;
UNIFORM vec4 UV_INFO;
UNIFORM vec4 PARTICLE_BOX;
END_UNIFORM_BLOCK

#endif

#ifndef _UNIFORM_PER_FRAME_CONSTANTS_H
#define _UNIFORM_PER_FRAME_CONSTANTS_H



#ifdef MCPE_PLATFORM_NX
layout(binding = 2) uniform PerFrameConstants {
#endif
// BEGIN_UNIFORM_BLOCK(PerFrameConstants) - unfortunately this macro does not work on old Amazon platforms so using above 3 lines instead
UNIFORM vec3 VIEW_POS;
#ifdef MCPE_NETEASE
// TIME will loop from [0, 210]
// make sure your shader handles the case when it transitions from 210 to 0
#endif
UNIFORM float TIME;
#ifdef MCPE_NETEASE
UNIFORM vec4 BLEND_COLOR;
UNIFORM vec4 USER_FOR_COLOR_NEAR;
UNIFORM vec4 USER_FOR_COLOR_FAR;
#endif
UNIFORM vec4 FOG_COLOR;
UNIFORM vec2 FOG_CONTROL;
UNIFORM float RENDER_DISTANCE;
UNIFORM float FAR_CHUNKS_DISTANCE;
UNIFORM float OCCLUSION_HEIGHT_OFFSET;
END_UNIFORM_BLOCK

#endif


attribute mediump vec4 POSITION;
attribute vec2 TEXCOORD_0;
attribute vec4 COLOR;

varying vec2 uv;
varying vec4 color;
varying vec4 worldPosition;
varying vec4 fogColor;

void main()
{
	float spriteSelector = COLOR.x*255.0;
	uv = UV_INFO.xy + (TEXCOORD_0 * UV_INFO.zw);
#ifndef NO_VARIETY
	uv.x += spriteSelector * UV_INFO.z;
#endif

	vec3 pos = POSITION.xyz;
		
	// subtract the offset then fmod into (0.0f, PARTICLE_BOX)
	pos.xyz += POSITION_OFFSET.xyz;
	pos.xyz = mod(pos.xyz, PARTICLE_BOX.xyz);
	
	// centre box on origin
	pos.xyz -= PARTICLE_BOX.xyz * 0.5;
	
	// push along view vector so box is positioned more infront of camera
	pos.xyz += FORWARD.xyz;
	
	// get world position
	vec4 worldPositionBottom = vec4(pos.xyz, 1.0);
	vec4 worldPositionTop = vec4(worldPositionBottom.xyz + (VELOCITY.xyz * SIZE_SCALE.y), 1.0);

	// get projected positions of top and bottom of particle, and top of particle in previous frame
	vec4 bottom = WORLDVIEWPROJ * worldPositionBottom;
	vec4 top = WORLDVIEWPROJ * worldPositionTop;
	
	// get 2d vector in screenspace between top and bottom of particle
	vec2 dir = normalize((top.xy/top.w) - (bottom.xy/bottom.w));
	
	// get 2d vector perpendicular to velocity
	vec2 dirPerp = normalize(vec2(-dir.y, dir.x));

	// choose either the top or bottom projected position using uv.y
	gl_Position = mix(top, bottom, TEXCOORD_0.y);
	 	
	// offset the position of each side of the particle using uv.x 
	gl_Position.xy += (0.5 - TEXCOORD_0.x) * dirPerp * SIZE_SCALE.x;
	
	color = ALPHA.rgba;

#if defined(COMFORT_MODE) && defined(VR_MODE)
	if (gl_Position.z < 2.0) {
		color.a = clamp((gl_Position.z - 1.2)/0.8, 0.0, 1.0);
	}
#endif

	//fog
    fogColor.rgb = FOG_COLOR.rgb;
	fogColor.a = clamp(((bottom.z / RENDER_DISTANCE) - FOG_CONTROL.x) / (FOG_CONTROL.y - FOG_CONTROL.x), 0.0, 1.0);

	worldPositionBottom.xz += VIEW_POSITION.xz;
	worldPositionBottom.xz *= 1.0 / 64.0;	// Scale by 1/TextureDimensions to get values between
	worldPositionBottom.xz += 0.5;			// Offset so that center of view is in the center of occlusion texture
	worldPositionBottom.y += VIEW_POSITION.y - 0.5;
	worldPositionBottom.y *= 1.0/255.0;
	worldPosition = worldPositionBottom;
}
