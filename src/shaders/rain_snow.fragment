// __multiversion__
// This signals the loading code to prepend either #version 100 or #version 300 es as apropriate.

// To use centroid sampling we need to have version 300 es shaders, which requires changing:
// attribute to in
// varying to out when in vertex shaders or in when in fragment shaders
// defining an out vec4 FragColor and replacing uses of gl_FragColor with FragColor
// texture2D to texture
#if __VERSION__ >= 300

// version 300 code

#define varying in
#define texture2D texture
out vec4 FragColor;
#define gl_FragColor FragColor

#else

// version 100 code

#endif


precision highp float;

#ifndef _UNIFORM_MACRO_H
#define _UNIFORM_MACRO_H

#ifdef MCPE_PLATFORM_NX
// Unfortunately this macro does not work on old Amazon platforms #define BEGIN_UNIFORM_BLOCK(x) uniform x {
#define END_UNIFORM_BLOCK };
#define UNIFORM 
#else
// Unfortunately this macro does not work on old Amazon platforms #define BEGIN_UNIFORM_BLOCK(x) 
#define END_UNIFORM_BLOCK
#define UNIFORM uniform 
#endif

#if __VERSION__ >= 420
#define LAYOUT_BINDING(x) layout(binding = x)
#else
#define LAYOUT_BINDING(x) 
#endif

#endif

#ifndef _UNIFORM_PER_FRAME_CONSTANTS_H
#define _UNIFORM_PER_FRAME_CONSTANTS_H



#ifdef MCPE_PLATFORM_NX
layout(binding = 2) uniform PerFrameConstants {
#endif
// BEGIN_UNIFORM_BLOCK(PerFrameConstants) - unfortunately this macro does not work on old Amazon platforms so using above 3 lines instead
UNIFORM vec3 VIEW_POS;
#ifdef MCPE_NETEASE
// TIME will loop from [0, 210]
// make sure your shader handles the case when it transitions from 210 to 0
#endif
UNIFORM float TIME;
#ifdef MCPE_NETEASE
UNIFORM vec4 BLEND_COLOR;
UNIFORM vec4 USER_FOR_COLOR_NEAR;
UNIFORM vec4 USER_FOR_COLOR_FAR;
#endif
UNIFORM vec4 FOG_COLOR;
UNIFORM vec2 FOG_CONTROL;
UNIFORM float RENDER_DISTANCE;
UNIFORM float FAR_CHUNKS_DISTANCE;
UNIFORM float OCCLUSION_HEIGHT_OFFSET;
END_UNIFORM_BLOCK

#endif


LAYOUT_BINDING(0) uniform sampler2D TEXTURE_0;
LAYOUT_BINDING(1) uniform sampler2D TEXTURE_1;
LAYOUT_BINDING(2) uniform sampler2D TEXTURE_2;

varying vec2 uv;
varying vec4 color;
varying vec4 worldPosition;
varying vec4 fogColor;

void main()
{
	vec4 albedo = texture2D( TEXTURE_0, uv);

#ifdef ALPHA_TEST
	if (albedo.a < 0.5)
		discard;
#endif

	albedo.a *= color.a;

	vec2 occlusionUV = worldPosition.xz;
	vec4 occlusionTexture = texture2D( TEXTURE_1, occlusionUV);

#ifndef FLIP_OCCLUSION
#define OCCLUSION_OPERATOR <
#else
#define OCCLUSION_OPERATOR >
#endif

#define OCCLUSION_LUMINANCE occlusionTexture.r
#define OCCLUSION_HEIGHT_ONES occlusionTexture.g
#define OCCLUSION_HEIGHT_TENS occlusionTexture.b

	float occlusion_height = OCCLUSION_HEIGHT_ONES + (OCCLUSION_HEIGHT_TENS * 255.0f) - (OCCLUSION_HEIGHT_OFFSET / 255.0f);

#ifndef NO_OCCLUSION
	// clamp the uvs
	if ( occlusionUV.x >= 0.0 && occlusionUV.x <= 1.0 && 
		 occlusionUV.y >= 0.0 && occlusionUV.y <= 1.0 && 
		 worldPosition.y OCCLUSION_OPERATOR occlusion_height) {
		albedo.a = 0.0;
	}
#endif

	float mixAmount = (worldPosition.y - occlusion_height)*25.0;
	vec2 lightingUVs = vec2(OCCLUSION_LUMINANCE, 1.0);
	lightingUVs.x = mix(lightingUVs.x, 0.0, mixAmount);

	vec3 lighting = texture2D( TEXTURE_2, lightingUVs ).rgb;
	vec4 finalOutput = albedo;
	finalOutput.rgb *= lighting.rgb;

	//apply fog
	gl_FragColor.rgb = mix( finalOutput.rgb, fogColor.rgb, fogColor.a );
	gl_FragColor.a = finalOutput.a;
}

